https://refactoringguru.cn/

1. 设计模式是常见问题的典型解决方案

2. 创建型模式: 提供创建对象的机制, 提供代码的可用性和复用性

3. 结构型模式: 介绍将对象和类组装成较大的结构, 并保持结构的灵活和高效

4. 行为型模式: 负责对象间的高效沟通和责任派委

创建型模式
简单工厂模式 : 工厂类里面根据条件实例化对象
工厂接口 : 
1. 工厂模式 : 通过工厂类里面的方法去实例化对象
2. 抽象工厂模式 : 工厂类里面多个实例化对象的方法

3. 建造者模式 : Builder里面new 一个对象, 组装类里面用Builder的方法赋值
重叠构造器模式 : 构造器的数量多, 参数代表模糊
javabean模式 : 线程不安全
lombok : 
@Builder : 流式set值写法
@Data = @Getter/@Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor 
@Value 所有的变量都设成 final = @Getter (注意没有setter), @ToString, @EqualsAndHashCode, @RequiredArgsConstructor

4. 原型模式: 复制对象
比直接new 一个对象
浅克隆: 实现Cloneable接口
浅克隆只是创建了一个新的对象，新对象中的引用类型属性指向的还是原对象中相应的引用类型属性的地址
深克隆: 保存对象状态

5. 单例模式
恶汉模式: 最常用, 耗资源, 类装载时完成实例化
懒汉模式: getInstance时完成实例化, 有线程安全问题, 不同线程得到不同实例
把类加上Synchronized
静态内部类: 类似于饿汉模式

结构型模式
1. 适配器模式: 调用接口实现 去实现另一个接口 JDBC 框架; Spring MVC 框架; 日志框架

2. 桥接模式: 分离再组合 InputStreamReader

3. 组合模式: 数据结构二叉树

4. 装饰模式: 不改变原有类结构的情况下，为对象添加新的行为或功能。

5. 门面模式: 统一接口里面多个接口按步骤执行

6. 享元模式: 创建对象池 连接池

7. 代理模式: 切面编程
JDK实现接口 InvocationHandler; 只能代理接口类
 CGLIB 实现接口 MethodInterceptor
代理类调用实现接口的类, 隐藏细节, 补充功能
Java反射机制来实现; AOP, IOC功能

行为型模式
0. 解释器模式: 这种模式被用在 SQL 解析、符号处理引擎等。进行安全检测的 判断你传进来的数据格式是否符合

1. 责任链模式: 将对象封装成集合, 形成不同的责任链模式

2. 命令模式: ConvreteCommand里转调接收者, Invoker调用执行

根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作

3. 迭代器模式: 不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素

4. 中介者模式: 通过一个中介者对象进行合作, 具体的中介者-中央处理系统; MVC模式

5. 备忘录模式: 管理者可以在任意时刻保存多个备忘录对象

6. 观察者模式: 观察者模式类似于责任链模式，所以观察者模式一般配合责任链模式使用

7. 状态模式: 责任链模式的单个情况

8. 策略模式: 使用算法Map消除if...else

9. 模板方法模式: 超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。
抽象类中抽象方法被重写, 被重写的方法属于抽象类中方法的其中一步

10. 访问者模式: 它能将算法与其所作用的对象隔离开来。
由一个类完成对象和算法的组合

